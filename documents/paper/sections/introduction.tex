The high-level programming language Java does not support simple aggregate types such as C-style structures (struct) or unions\cite{b1}.
Consequently, a variety of libraries have been developed to bridge this gap and enable interaction with native memory layouts\cite{b2}.
This study introduces a novel approach to dynamically create aggregate types from special Java classes at runtime, while
providing support for different Application Binary Interfaces (ABI).
Especially in performance critical applications, like real-time rendering, different ABIs are required to transfer structures
to graphic processors using Vulkan, OpenGL or OpenCL\@.
These ABIs are not supported by current Java native interop libraries.
LUtils includes multiple ABIs and provides the developer with the ability to implement custom ABIs. However, it has as not
seen much usage in real-world applications and is missing comparisons to already existing libraries in terms of performance and
memory usage.
Therefore, this paper aims to compare the performance of LUtils against existing solutions – namely Lightweight Java Game
Library (LWJGL), Foreign Functions and Memory API (FFMA) and Java Native Access (JNA) – in
terms of structure creation, write/read operations, and startup costs.
Thereby, answering whether LUtils can be used in performance-critical applications or if other libraries should be preferred.

There have been many studies analysing performance of Java native interop libraries with respect to structures.
However, one remotely related approach\cite{b3} aims to improve memory performance of embedded Java applications.
It discusses dynamically changing the memory layout of arrays on embedded systems to improve performance.
Other research\cite{b4,b5,b6} discusses common practices and security related issues of the Java Native Interface (JNI).
Another study\cite{b7} evaluates the performance of the Java Vector API in vector embedding operations, comparing it to pure
Java solutions and C++ implementations called from Java.

Another related study\cite{b8} discusses and compares tools that asses ABI compatibility.
These tools predict ABI incompatibility and detect potential bugs arising from ABI mismatches.
Furthermore, the work highlights reasons why ABI compatibility can be problematic and how an understanding of ABIs might
be required to solve ABI related problems.

The work most closely related to this paper is the bachelor’s thesis by Niklas Seppälä\cite{b9},which investigates whether
Java native interop can improve performance compared to purely Java-based implementations.
That study focuses on JNI, JNA and FFMA, concluding that utilizing Java native interop is most suitable for larger tasks,
which minimize communication between Java and native code.
This represents the key difference to the approach presented by the present paper, which aims to analyse the impact of
creating and accessing structures in Java code without passing the structures to native code.

The rest of this article is organized as follows: TODO